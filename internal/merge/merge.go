package merge

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/HartBrook/staghorn/internal/language"
)

// Layer represents a config layer with its source.
type Layer struct {
	Content string
	Source  string // "team" | "personal" | "project"
}

// MergeOptions controls merge behavior.
type MergeOptions struct {
	AnnotateSources bool                                // Add source comments
	SourceRepo      string                              // For header annotation (e.g., "acme/standards")
	Languages       []string                            // Active languages to include
	LanguageFiles   map[string][]*language.LanguageFile // Language files by language ID
}

// Merge combines layers into a single document.
// Order: team (base) -> personal -> project
// Returns the merged markdown content.
func Merge(layers []Layer, opts MergeOptions) string {
	if len(layers) == 0 {
		return ""
	}

	// Start with the first non-empty layer as base
	var baseDoc *Document
	var baseSource string
	for _, layer := range layers {
		if strings.TrimSpace(layer.Content) != "" {
			baseDoc = Parse(layer.Content)
			baseSource = layer.Source
			break
		}
	}

	if baseDoc == nil {
		return ""
	}

	// Merge additional layers into base
	for _, layer := range layers {
		if layer.Source == baseSource || strings.TrimSpace(layer.Content) == "" {
			continue
		}
		mergeLayer(baseDoc, layer)
	}

	// Render the merged document
	return render(baseDoc, opts)
}

// mergeLayer merges a layer into the base document.
func mergeLayer(base *Document, layer Layer) {
	doc := Parse(layer.Content)
	label := formatAdditionLabel(layer.Source)

	// Merge sections
	for _, section := range doc.Sections {
		// Skip sections with no meaningful content
		if strings.TrimSpace(section.Content) == "" {
			continue
		}

		existingSection := base.FindSection(section.Header)
		if existingSection != nil {
			// Append to existing section with sub-header
			existingSection.Content = appendWithSubHeader(
				existingSection.Content,
				section.Content,
				label,
			)
		} else {
			// Add as new section
			base.Sections = append(base.Sections, Section{
				Header:  section.Header,
				Content: section.Content,
			})
		}
	}
}

// formatAdditionLabel returns the sub-header label for a source.
func formatAdditionLabel(source string) string {
	switch source {
	case "personal":
		return "Personal Additions"
	case "project":
		return "Project Additions"
	default:
		return titleCase(source) + " Additions"
	}
}

// titleCase capitalizes the first letter of a string.
func titleCase(s string) string {
	if s == "" {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

// appendWithSubHeader appends content under a ### sub-header.
func appendWithSubHeader(base, addition, label string) string {
	if strings.TrimSpace(addition) == "" {
		return base
	}
	return fmt.Sprintf("%s\n\n### %s\n\n%s", base, label, addition)
}

// render converts a Document back to markdown.
func render(doc *Document, opts MergeOptions) string {
	var b strings.Builder

	// Header comment
	if opts.AnnotateSources {
		timestamp := time.Now().Format("2006-01-02")
		if opts.SourceRepo != "" {
			b.WriteString(fmt.Sprintf("<!-- Generated by staghorn | Source: %s | %s -->\n\n", opts.SourceRepo, timestamp))
		} else {
			b.WriteString(fmt.Sprintf("<!-- Generated by staghorn | %s -->\n\n", timestamp))
		}
	}

	// Preamble
	if doc.Preamble != "" {
		b.WriteString(doc.Preamble)
		b.WriteString("\n\n")
	}

	// Sections
	for i, section := range doc.Sections {
		b.WriteString(fmt.Sprintf("## %s\n\n", section.Header))
		b.WriteString(section.Content)
		if i < len(doc.Sections)-1 {
			b.WriteString("\n\n")
		}
	}

	return strings.TrimSpace(b.String())
}

// MergeSimple merges multiple markdown contents without layer metadata.
// Useful for simple cases where source tracking isn't needed.
func MergeSimple(contents ...string) string {
	layers := make([]Layer, len(contents))
	sources := []string{"team", "personal", "project"}

	for i, content := range contents {
		source := "unknown"
		if i < len(sources) {
			source = sources[i]
		}
		layers[i] = Layer{Content: content, Source: source}
	}

	return Merge(layers, MergeOptions{})
}

// MergeWithLanguages performs the full merge including language configs.
// First merges base layers, then appends a language-specific section.
func MergeWithLanguages(layers []Layer, opts MergeOptions) string {
	// First, merge the base layers (team -> personal -> project)
	baseResult := Merge(layers, opts)

	if len(opts.Languages) == 0 || len(opts.LanguageFiles) == 0 {
		return baseResult
	}

	// Build and append language section
	languageSection := buildLanguageSection(opts.Languages, opts.LanguageFiles)
	if languageSection == "" {
		return baseResult
	}

	return baseResult + "\n\n" + languageSection
}

// buildLanguageSection creates the language-specific guidelines section.
func buildLanguageSection(languages []string, files map[string][]*language.LanguageFile) string {
	if len(files) == 0 {
		return ""
	}

	// Sort languages for consistent output
	sortedLangs := make([]string, 0, len(languages))
	for _, lang := range languages {
		if _, ok := files[lang]; ok {
			sortedLangs = append(sortedLangs, lang)
		}
	}
	sort.Strings(sortedLangs)

	if len(sortedLangs) == 0 {
		return ""
	}

	var b strings.Builder
	b.WriteString("## Language-Specific Guidelines\n")

	for _, lang := range sortedLangs {
		langFiles := files[lang]
		if len(langFiles) == 0 {
			continue
		}

		displayName := language.GetDisplayName(lang)
		b.WriteString(fmt.Sprintf("\n### %s\n\n", displayName))

		// Merge language files from all layers
		for i, file := range langFiles {
			content := strings.TrimSpace(file.Content)
			if content == "" {
				continue
			}

			if i == 0 {
				// First layer (team) - write content directly
				b.WriteString(content)
			} else {
				// Personal/project additions get sub-headers
				label := formatAdditionLabel(file.Source)
				b.WriteString(fmt.Sprintf("\n\n#### %s\n\n%s", label, content))
			}
		}
	}

	return strings.TrimSpace(b.String())
}
