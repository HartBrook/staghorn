package merge

import (
	"regexp"
	"strings"
)

// Header comment prefixes used for generation and stripping.
const (
	// HeaderManagedPrefix is the prefix for the "managed by staghorn" comment.
	HeaderManagedPrefix = "<!-- Managed by staghorn"
	// HeaderGeneratedPrefix is the prefix for the "generated by staghorn" comment.
	HeaderGeneratedPrefix = "<!-- Generated by staghorn"
)

// ProvenanceSection represents a section of content with its source.
type ProvenanceSection struct {
	Source   string // The source layer (team, personal, project)
	Language string // Optional language subsection (python, go, etc.) - empty for main content
	Content  string // The content from this source
}

// FullSource returns the complete source identifier (e.g., "team" or "team:python").
func (p ProvenanceSection) FullSource() string {
	if p.Language != "" {
		return p.Source + ":" + p.Language
	}
	return p.Source
}

// sourceMarkerRegex matches provenance markers in merged configs.
// Example matches:
//   - <!-- staghorn:source:team --> (main team content)
//   - <!-- staghorn:source:personal --> (main personal content)
//   - <!-- staghorn:source:team:python --> (team's python guidelines)
//   - <!-- staghorn:source:personal:go --> (personal's go additions)
//
// Captures:
//   - Group 1: layer (team, personal, project)
//   - Group 2: optional language (python, go, etc.)
var sourceMarkerRegex = regexp.MustCompile(`<!--\s*staghorn:source:(\w+)(?::(\w+))?\s*-->`)

// ParseProvenance extracts content grouped by full source from a merged config.
// Returns a map of full source (e.g., "team", "team:python") -> content.
// Content from each source is concatenated.
func ParseProvenance(content string) map[string]string {
	result := make(map[string]string)
	sections := ParseProvenanceSections(content)

	for _, section := range sections {
		key := section.FullSource()
		if existing, ok := result[key]; ok {
			result[key] = existing + "\n\n" + section.Content
		} else {
			result[key] = section.Content
		}
	}

	return result
}

// ParseProvenanceByLayer extracts content grouped by layer only (ignoring language subsections).
// Returns a map of layer (team, personal, project) -> content.
// This aggregates both main content and language-specific content for each layer.
func ParseProvenanceByLayer(content string) map[string]string {
	result := make(map[string]string)
	sections := ParseProvenanceSections(content)

	for _, section := range sections {
		if existing, ok := result[section.Source]; ok {
			result[section.Source] = existing + "\n\n" + section.Content
		} else {
			result[section.Source] = section.Content
		}
	}

	return result
}

// ParseProvenanceSections returns an ordered list of sections with their sources.
// This preserves the order and structure of the original document.
func ParseProvenanceSections(content string) []ProvenanceSection {
	var sections []ProvenanceSection

	// Strip header comments (<!-- Managed by staghorn... --> and <!-- Generated by staghorn... -->)
	content = stripHeaderComments(content)

	// Find all source markers and their positions
	matches := sourceMarkerRegex.FindAllStringSubmatchIndex(content, -1)

	if len(matches) == 0 {
		// No provenance markers - return entire content as unknown source
		trimmed := strings.TrimSpace(content)
		if trimmed != "" {
			sections = append(sections, ProvenanceSection{
				Source:  "unknown",
				Content: trimmed,
			})
		}
		return sections
	}

	// Extract content between markers
	for i, match := range matches {
		source := content[match[2]:match[3]] // Capture group 1: the source/layer name
		markerEnd := match[1]                // End of the full marker

		// Capture group 2: optional language (may be -1 if not present)
		var language string
		if match[4] != -1 && match[5] != -1 {
			language = content[match[4]:match[5]]
		}

		// Find the end of this section (start of next marker or end of content)
		var sectionEnd int
		if i < len(matches)-1 {
			sectionEnd = matches[i+1][0]
		} else {
			sectionEnd = len(content)
		}

		// Extract and clean the content
		sectionContent := strings.TrimSpace(content[markerEnd:sectionEnd])
		if sectionContent != "" {
			sections = append(sections, ProvenanceSection{
				Source:   source,
				Language: language,
				Content:  sectionContent,
			})
		}
	}

	return sections
}

// ExtractBySource extracts all content from a merged config that came from a specific source.
// Returns empty string if no content from that source is found.
func ExtractBySource(content, source string) string {
	provenance := ParseProvenance(content)
	return provenance[source]
}

// ListSources returns all unique full sources found in a merged config, in order of appearance.
// Returns full source identifiers (e.g., "team", "personal", "team:python").
func ListSources(content string) []string {
	var sources []string
	seen := make(map[string]bool)

	sections := ParseProvenanceSections(content)
	for _, section := range sections {
		fullSource := section.FullSource()
		if !seen[fullSource] {
			sources = append(sources, fullSource)
			seen[fullSource] = true
		}
	}

	return sources
}

// ListLayers returns all unique layers found in a merged config, in order of appearance.
// Returns only the layer names (team, personal, project), ignoring language subsections.
func ListLayers(content string) []string {
	var layers []string
	seen := make(map[string]bool)

	sections := ParseProvenanceSections(content)
	for _, section := range sections {
		if !seen[section.Source] {
			layers = append(layers, section.Source)
			seen[section.Source] = true
		}
	}

	return layers
}

// HasProvenance checks if the content contains provenance markers.
func HasProvenance(content string) bool {
	return sourceMarkerRegex.MatchString(content)
}

// stripHeaderComments removes the staghorn header comments from the content.
// It strips leading blank lines and header comments (Managed by staghorn, Generated by staghorn)
// until the first non-header content is encountered. If the file contains only header comments
// and blank lines, returns an empty string (which ParseProvenanceSections handles as empty content).
func stripHeaderComments(content string) string {
	lines := strings.Split(content, "\n")
	var result []string
	inHeader := true

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip header comments and blank lines at the start of the file
		if inHeader {
			if strings.HasPrefix(trimmed, HeaderManagedPrefix) ||
				strings.HasPrefix(trimmed, HeaderGeneratedPrefix) {
				continue
			}
			if trimmed == "" {
				continue
			}
			// First non-header, non-blank line marks end of header section
			inHeader = false
		}

		result = append(result, line)
	}

	return strings.Join(result, "\n")
}
