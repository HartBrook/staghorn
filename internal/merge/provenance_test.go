package merge

import (
	"strings"
	"testing"
)

func TestParseProvenance(t *testing.T) {
	content := `<!-- Managed by staghorn | Source: acme/standards | Do not edit directly -->

<!-- Generated by staghorn | Source: acme/standards | 2026-01-20 -->

<!-- staghorn:source:team -->
## Code Style

Team rules here.

## Testing

Write tests.

<!-- staghorn:source:personal -->
### Personal Additions

My preferences.`

	result := ParseProvenance(content)

	// Should have two sources
	if len(result) != 2 {
		t.Errorf("expected 2 sources, got %d", len(result))
	}

	// Team content
	if !strings.Contains(result["team"], "Team rules here") {
		t.Error("team content should include 'Team rules here'")
	}
	if !strings.Contains(result["team"], "Write tests") {
		t.Error("team content should include 'Write tests'")
	}

	// Personal content
	if !strings.Contains(result["personal"], "My preferences") {
		t.Error("personal content should include 'My preferences'")
	}
}

func TestParseProvenanceSections(t *testing.T) {
	content := `<!-- staghorn:source:team -->
## Section 1

Team content.

<!-- staghorn:source:personal -->
### Personal

Personal content.

<!-- staghorn:source:team -->
## More Team

More team content.`

	sections := ParseProvenanceSections(content)

	if len(sections) != 3 {
		t.Fatalf("expected 3 sections, got %d", len(sections))
	}

	// First section
	if sections[0].Source != "team" {
		t.Errorf("section 0 source = %q, want 'team'", sections[0].Source)
	}
	if !strings.Contains(sections[0].Content, "Team content") {
		t.Error("section 0 should contain 'Team content'")
	}

	// Second section
	if sections[1].Source != "personal" {
		t.Errorf("section 1 source = %q, want 'personal'", sections[1].Source)
	}
	if !strings.Contains(sections[1].Content, "Personal content") {
		t.Error("section 1 should contain 'Personal content'")
	}

	// Third section
	if sections[2].Source != "team" {
		t.Errorf("section 2 source = %q, want 'team'", sections[2].Source)
	}
	if !strings.Contains(sections[2].Content, "More team content") {
		t.Error("section 2 should contain 'More team content'")
	}
}

func TestParseProvenanceSections_NoMarkers(t *testing.T) {
	content := `## Code Style

Some content without provenance markers.`

	sections := ParseProvenanceSections(content)

	if len(sections) != 1 {
		t.Fatalf("expected 1 section, got %d", len(sections))
	}

	if sections[0].Source != "unknown" {
		t.Errorf("source = %q, want 'unknown'", sections[0].Source)
	}
	if !strings.Contains(sections[0].Content, "Some content") {
		t.Error("should contain the content")
	}
}

func TestExtractBySource(t *testing.T) {
	content := `<!-- staghorn:source:team -->
## Team Section

Team content here.

<!-- staghorn:source:personal -->
### Personal

Personal content here.`

	// Extract team content
	team := ExtractBySource(content, "team")
	if !strings.Contains(team, "Team content here") {
		t.Error("team extraction should contain 'Team content here'")
	}
	if strings.Contains(team, "Personal content") {
		t.Error("team extraction should not contain personal content")
	}

	// Extract personal content
	personal := ExtractBySource(content, "personal")
	if !strings.Contains(personal, "Personal content here") {
		t.Error("personal extraction should contain 'Personal content here'")
	}

	// Extract non-existent source
	project := ExtractBySource(content, "project")
	if project != "" {
		t.Errorf("project extraction should be empty, got %q", project)
	}
}

func TestListSources(t *testing.T) {
	content := `<!-- staghorn:source:team -->
Team content.

<!-- staghorn:source:personal -->
Personal content.

<!-- staghorn:source:team -->
More team content.`

	sources := ListSources(content)

	if len(sources) != 2 {
		t.Fatalf("expected 2 unique sources, got %d: %v", len(sources), sources)
	}

	// Should preserve order of first appearance
	if sources[0] != "team" {
		t.Errorf("first source = %q, want 'team'", sources[0])
	}
	if sources[1] != "personal" {
		t.Errorf("second source = %q, want 'personal'", sources[1])
	}
}

func TestHasProvenance(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected bool
	}{
		{
			name:     "with provenance",
			content:  "<!-- staghorn:source:team -->\nContent",
			expected: true,
		},
		{
			name:     "without provenance",
			content:  "## Code Style\n\nContent",
			expected: false,
		},
		{
			name:     "with other comments",
			content:  "<!-- Managed by staghorn -->\n## Code Style",
			expected: false,
		},
		{
			name:     "empty content",
			content:  "",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := HasProvenance(tt.content)
			if result != tt.expected {
				t.Errorf("HasProvenance() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestStripHeaderComments(t *testing.T) {
	content := `<!-- Managed by staghorn | Source: acme/standards | Do not edit directly -->

<!-- Generated by staghorn | Source: acme/standards | 2026-01-20 -->

<!-- staghorn:source:team -->
## Code Style

Content here.`

	result := stripHeaderComments(content)

	// Should not contain header comments
	if strings.Contains(result, "Managed by staghorn") {
		t.Error("should strip 'Managed by staghorn' comment")
	}
	if strings.Contains(result, "Generated by staghorn") {
		t.Error("should strip 'Generated by staghorn' comment")
	}

	// Should preserve source markers
	if !strings.Contains(result, "staghorn:source:team") {
		t.Error("should preserve source markers")
	}

	// Should preserve content
	if !strings.Contains(result, "Content here") {
		t.Error("should preserve content")
	}
}

func TestParseProvenanceRoundTrip(t *testing.T) {
	// Test that content merged with provenance can be parsed back
	layers := []Layer{
		{Content: "## Code Style\n\nTeam rules.", Source: "team"},
		{Content: "## Code Style\n\nPersonal prefs.", Source: "personal"},
	}

	opts := MergeOptions{
		AnnotateSources: true,
		SourceRepo:      "acme/standards",
	}

	merged := Merge(layers, opts)

	// Parse the merged content
	provenance := ParseProvenance(merged)

	// Should have team content
	if !strings.Contains(provenance["team"], "Team rules") {
		t.Error("parsed team content should contain 'Team rules'")
	}

	// Should have personal content
	if !strings.Contains(provenance["personal"], "Personal prefs") {
		t.Error("parsed personal content should contain 'Personal prefs'")
	}
}

func TestParseProvenanceWithLanguage(t *testing.T) {
	content := `<!-- staghorn:source:team -->
## Code Style

Team rules.

<!-- staghorn:source:team:python -->
## Python Guidelines

Python team rules.

<!-- staghorn:source:personal:python -->
### Personal Additions

Python personal prefs.`

	sections := ParseProvenanceSections(content)

	if len(sections) != 3 {
		t.Fatalf("expected 3 sections, got %d", len(sections))
	}

	// First section - main team content
	if sections[0].Source != "team" || sections[0].Language != "" {
		t.Errorf("section 0: source=%q language=%q, want team with no language", sections[0].Source, sections[0].Language)
	}
	if sections[0].FullSource() != "team" {
		t.Errorf("section 0 FullSource = %q, want 'team'", sections[0].FullSource())
	}

	// Second section - team python
	if sections[1].Source != "team" || sections[1].Language != "python" {
		t.Errorf("section 1: source=%q language=%q, want team:python", sections[1].Source, sections[1].Language)
	}
	if sections[1].FullSource() != "team:python" {
		t.Errorf("section 1 FullSource = %q, want 'team:python'", sections[1].FullSource())
	}

	// Third section - personal python
	if sections[2].Source != "personal" || sections[2].Language != "python" {
		t.Errorf("section 2: source=%q language=%q, want personal:python", sections[2].Source, sections[2].Language)
	}
	if sections[2].FullSource() != "personal:python" {
		t.Errorf("section 2 FullSource = %q, want 'personal:python'", sections[2].FullSource())
	}
}

func TestParseProvenanceByLayer(t *testing.T) {
	content := `<!-- staghorn:source:team -->
## Code Style

Team main rules.

<!-- staghorn:source:team:python -->
### Python

Python team rules.

<!-- staghorn:source:personal -->
### Personal Additions

Personal main prefs.

<!-- staghorn:source:personal:python -->
#### Personal Additions

Python personal prefs.`

	// ParseProvenance groups by full source
	fullProvenance := ParseProvenance(content)
	if len(fullProvenance) != 4 {
		t.Errorf("ParseProvenance: expected 4 sources, got %d: %v", len(fullProvenance), fullProvenance)
	}
	if _, ok := fullProvenance["team"]; !ok {
		t.Error("ParseProvenance should have 'team' key")
	}
	if _, ok := fullProvenance["team:python"]; !ok {
		t.Error("ParseProvenance should have 'team:python' key")
	}

	// ParseProvenanceByLayer groups by layer only
	layerProvenance := ParseProvenanceByLayer(content)
	if len(layerProvenance) != 2 {
		t.Errorf("ParseProvenanceByLayer: expected 2 layers, got %d: %v", len(layerProvenance), layerProvenance)
	}

	// Team layer should include both main and python content
	if !strings.Contains(layerProvenance["team"], "Team main rules") {
		t.Error("team layer should contain main content")
	}
	if !strings.Contains(layerProvenance["team"], "Python team rules") {
		t.Error("team layer should contain python content")
	}

	// Personal layer should include both main and python content
	if !strings.Contains(layerProvenance["personal"], "Personal main prefs") {
		t.Error("personal layer should contain main content")
	}
	if !strings.Contains(layerProvenance["personal"], "Python personal prefs") {
		t.Error("personal layer should contain python content")
	}
}

func TestListSourcesWithLanguage(t *testing.T) {
	content := `<!-- staghorn:source:team -->
Team content.

<!-- staghorn:source:team:python -->
Python team.

<!-- staghorn:source:personal:python -->
Python personal.`

	sources := ListSources(content)

	// Should have 3 unique full sources
	if len(sources) != 3 {
		t.Fatalf("expected 3 sources, got %d: %v", len(sources), sources)
	}

	// Should preserve order
	if sources[0] != "team" {
		t.Errorf("sources[0] = %q, want 'team'", sources[0])
	}
	if sources[1] != "team:python" {
		t.Errorf("sources[1] = %q, want 'team:python'", sources[1])
	}
	if sources[2] != "personal:python" {
		t.Errorf("sources[2] = %q, want 'personal:python'", sources[2])
	}
}

func TestListLayers(t *testing.T) {
	content := `<!-- staghorn:source:team -->
Team content.

<!-- staghorn:source:team:python -->
Python team.

<!-- staghorn:source:personal:python -->
Python personal.`

	layers := ListLayers(content)

	// Should have 2 unique layers (team, personal)
	if len(layers) != 2 {
		t.Fatalf("expected 2 layers, got %d: %v", len(layers), layers)
	}

	if layers[0] != "team" {
		t.Errorf("layers[0] = %q, want 'team'", layers[0])
	}
	if layers[1] != "personal" {
		t.Errorf("layers[1] = %q, want 'personal'", layers[1])
	}
}

func TestHasProvenanceWithLanguage(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected bool
	}{
		{
			name:     "basic source marker",
			content:  "<!-- staghorn:source:team -->\nContent",
			expected: true,
		},
		{
			name:     "language source marker",
			content:  "<!-- staghorn:source:team:python -->\nContent",
			expected: true,
		},
		{
			name:     "mixed markers",
			content:  "<!-- staghorn:source:team -->\nContent\n<!-- staghorn:source:personal:go -->",
			expected: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := HasProvenance(tt.content)
			if result != tt.expected {
				t.Errorf("HasProvenance() = %v, want %v", result, tt.expected)
			}
		})
	}
}
