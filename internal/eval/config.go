package eval

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v3"
)

// PromptfooConfig represents a Promptfoo configuration file.
type PromptfooConfig struct {
	Description string          `yaml:"description,omitempty"`
	Prompts     []string        `yaml:"prompts"`
	Providers   []string        `yaml:"providers"`
	Tests       []PromptfooTest `yaml:"tests"`
	OutputPath  string          `yaml:"outputPath,omitempty"`
}

// PromptfooTest represents a test case in Promptfoo format.
type PromptfooTest struct {
	Description string                 `yaml:"description,omitempty"`
	Vars        map[string]interface{} `yaml:"vars"`
	Assert      []PromptfooAssertion   `yaml:"assert"`
}

// PromptfooAssertion represents an assertion in Promptfoo format.
type PromptfooAssertion struct {
	Type  string      `yaml:"type"`
	Value interface{} `yaml:"value,omitempty"`
}

// GenerateOptions configures Promptfoo config generation.
type GenerateOptions struct {
	// OutputDir is the directory to write the Promptfoo config to.
	OutputDir string

	// ResultsPath is the path for Promptfoo to write results to.
	ResultsPath string
}

// GeneratePromptfooConfig creates a Promptfoo config from an eval definition.
func GeneratePromptfooConfig(e *Eval, claudeConfig string, opts GenerateOptions) (*PromptfooConfig, error) {
	// Build the prompt as a JSON array of messages (required format for chat models)
	// Promptfoo expects prompts as strings, and for chat models we use JSON format
	messages := []map[string]string{
		{"role": "system", "content": claudeConfig},
		{"role": "user", "content": "{{query}}"},
	}
	promptJSON, err := json.Marshal(messages)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal prompt: %w", err)
	}

	// Convert eval tests to Promptfoo tests
	var tests []PromptfooTest
	for _, t := range e.Tests {
		vars := make(map[string]interface{})

		// Copy any custom vars
		for k, v := range t.Vars {
			vars[k] = v
		}

		// Set the query from the prompt
		vars["query"] = strings.TrimSpace(t.Prompt)

		// Convert assertions
		var assertions []PromptfooAssertion
		for _, a := range t.Assert {
			assertions = append(assertions, PromptfooAssertion(a))
		}

		description := t.Description
		if description == "" {
			description = t.Name
		}

		tests = append(tests, PromptfooTest{
			Description: description,
			Vars:        vars,
			Assert:      assertions,
		})
	}

	// Build provider string
	model := e.ResolveModel()
	provider := fmt.Sprintf("anthropic:messages:%s", model)

	config := &PromptfooConfig{
		Description: e.Description,
		Prompts:     []string{string(promptJSON)},
		Providers:   []string{provider},
		Tests:       tests,
	}

	if opts.ResultsPath != "" {
		config.OutputPath = opts.ResultsPath
	}

	return config, nil
}

// WritePromptfooConfig writes a Promptfoo config to a file.
func WritePromptfooConfig(config *PromptfooConfig, path string) error {
	// Ensure directory exists
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	data, err := yaml.Marshal(config)
	if err != nil {
		return fmt.Errorf("failed to marshal config: %w", err)
	}

	// Add a header comment
	header := "# Generated by staghorn eval - do not edit directly\n"
	content := header + string(data)

	if err := os.WriteFile(path, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	return nil
}

// GeneratePromptfooConfigAlt generates an alternative format that puts
// the system prompt inline with tests for cleaner output.
func GeneratePromptfooConfigAlt(e *Eval, claudeConfig string) ([]byte, error) {
	// Build the full prompt template with system context
	promptTemplate := fmt.Sprintf(`[
  {"role": "system", "content": %q},
  {"role": "user", "content": "{{query}}"}
]`, claudeConfig)

	// Build tests
	var tests []map[string]interface{}
	for _, t := range e.Tests {
		test := map[string]interface{}{
			"description": t.Name,
			"vars": map[string]interface{}{
				"query": strings.TrimSpace(t.Prompt),
			},
		}

		// Add custom vars
		if len(t.Vars) > 0 {
			varsMap := test["vars"].(map[string]interface{})
			for k, v := range t.Vars {
				varsMap[k] = v
			}
		}

		// Add assertions
		var assertions []map[string]interface{}
		for _, a := range t.Assert {
			assertion := map[string]interface{}{
				"type": a.Type,
			}
			if a.Value != nil {
				assertion["value"] = a.Value
			}
			assertions = append(assertions, assertion)
		}
		test["assert"] = assertions

		tests = append(tests, test)
	}

	config := map[string]interface{}{
		"description": e.Description,
		"prompts":     []string{promptTemplate},
		"providers":   []string{fmt.Sprintf("anthropic:messages:%s", e.ResolveModel())},
		"tests":       tests,
	}

	return yaml.Marshal(config)
}
