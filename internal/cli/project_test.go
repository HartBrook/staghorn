package cli

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/HartBrook/staghorn/internal/config"
)

func TestGenerateProjectOutput(t *testing.T) {
	// Create temp directory
	tempDir := t.TempDir()
	paths := config.NewProjectPaths(tempDir)

	// Create .staghorn directory and source file
	if err := os.MkdirAll(paths.StaghornDir, 0755); err != nil {
		t.Fatalf("failed to create .staghorn dir: %v", err)
	}

	sourceContent := `# My Project

## Guidelines

- Be concise
- Write tests`

	if err := os.WriteFile(paths.SourceMD, []byte(sourceContent), 0644); err != nil {
		t.Fatalf("failed to write source: %v", err)
	}

	// Generate output
	if err := generateProjectOutput(paths); err != nil {
		t.Fatalf("generateProjectOutput failed: %v", err)
	}

	// Read and verify output
	output, err := os.ReadFile(paths.OutputMD)
	if err != nil {
		t.Fatalf("failed to read output: %v", err)
	}

	outputStr := string(output)

	// Check header is present
	if !strings.HasPrefix(outputStr, "<!-- Generated by staghorn") {
		t.Error("output should start with staghorn header")
	}

	// Check content is preserved
	if !strings.Contains(outputStr, "# My Project") {
		t.Error("output should contain source content")
	}

	if !strings.Contains(outputStr, "- Be concise") {
		t.Error("output should contain source content")
	}
}

func TestGenerateProjectOutput_TrimsWhitespace(t *testing.T) {
	tempDir := t.TempDir()
	paths := config.NewProjectPaths(tempDir)

	if err := os.MkdirAll(paths.StaghornDir, 0755); err != nil {
		t.Fatalf("failed to create .staghorn dir: %v", err)
	}

	// Source with extra whitespace
	sourceContent := `

# My Project

Content here


`
	if err := os.WriteFile(paths.SourceMD, []byte(sourceContent), 0644); err != nil {
		t.Fatalf("failed to write source: %v", err)
	}

	if err := generateProjectOutput(paths); err != nil {
		t.Fatalf("generateProjectOutput failed: %v", err)
	}

	output, err := os.ReadFile(paths.OutputMD)
	if err != nil {
		t.Fatalf("failed to read output: %v", err)
	}

	// Should end with single newline, not multiple
	if strings.HasSuffix(string(output), "\n\n") {
		t.Error("output should not have trailing blank lines")
	}

	if !strings.HasSuffix(string(output), "\n") {
		t.Error("output should end with a newline")
	}
}

func TestListAvailableTemplates(t *testing.T) {
	tempDir := t.TempDir()

	// Create some template files
	templates := []string{"backend.md", "frontend.md", "library.md"}
	for _, name := range templates {
		path := filepath.Join(tempDir, name)
		if err := os.WriteFile(path, []byte("# Template"), 0644); err != nil {
			t.Fatalf("failed to create template: %v", err)
		}
	}

	// Create a non-md file that should be ignored
	if err := os.WriteFile(filepath.Join(tempDir, "README.txt"), []byte("ignore me"), 0644); err != nil {
		t.Fatalf("failed to create txt file: %v", err)
	}

	// Create a subdirectory that should be ignored
	if err := os.MkdirAll(filepath.Join(tempDir, "subdir"), 0755); err != nil {
		t.Fatalf("failed to create subdir: %v", err)
	}

	result := listAvailableTemplates(tempDir)

	if len(result) != 3 {
		t.Errorf("expected 3 templates, got %d: %v", len(result), result)
	}

	// Check names don't have .md suffix
	for _, name := range result {
		if strings.HasSuffix(name, ".md") {
			t.Errorf("template name should not have .md suffix: %s", name)
		}
	}

	// Check expected templates are present
	expected := map[string]bool{"backend": true, "frontend": true, "library": true}
	for _, name := range result {
		if !expected[name] {
			t.Errorf("unexpected template: %s", name)
		}
	}
}

func TestListAvailableTemplates_EmptyDir(t *testing.T) {
	tempDir := t.TempDir()

	result := listAvailableTemplates(tempDir)

	if len(result) != 0 {
		t.Errorf("expected empty slice for empty dir, got %v", result)
	}
}

func TestListAvailableTemplates_NonexistentDir(t *testing.T) {
	result := listAvailableTemplates("/nonexistent/path")

	if result != nil {
		t.Errorf("expected nil for nonexistent dir, got %v", result)
	}
}

func TestGetTemplateDescription(t *testing.T) {
	tempDir := t.TempDir()

	tests := []struct {
		name     string
		content  string
		expected string
	}{
		{
			name: "description after heading",
			content: `# Backend Service

Guidelines for backend services.

## More content`,
			expected: "Guidelines for backend services.",
		},
		{
			name: "skips html comments",
			content: `# Template
<!-- This is a comment -->

Actual description here.`,
			expected: "Actual description here.",
		},
		{
			name: "truncates long descriptions",
			content: `# Template

This is a very long description that exceeds fifty characters and should be truncated.`,
			expected: "This is a very long description that exceeds fi...",
		},
		{
			name:     "no description available",
			content:  `# Just a Heading`,
			expected: "(no description)",
		},
		{
			name: "skips multiple headings",
			content: `# Title
## Subtitle
### Another

Finally some text.`,
			expected: "Finally some text.",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			path := filepath.Join(tempDir, tt.name+".md")
			if err := os.WriteFile(path, []byte(tt.content), 0644); err != nil {
				t.Fatalf("failed to write test file: %v", err)
			}

			result := getTemplateDescription(path)
			if result != tt.expected {
				t.Errorf("getTemplateDescription() = %q, want %q", result, tt.expected)
			}
		})
	}
}

func TestGetTemplateDescription_NonexistentFile(t *testing.T) {
	result := getTemplateDescription("/nonexistent/file.md")
	if result != "(no description)" {
		t.Errorf("expected '(no description)' for nonexistent file, got %q", result)
	}
}

func TestRelativePath(t *testing.T) {
	cwd, err := os.Getwd()
	if err != nil {
		t.Fatalf("failed to get cwd: %v", err)
	}

	tests := []struct {
		name     string
		path     string
		expected string
	}{
		{
			name:     "path in cwd",
			path:     filepath.Join(cwd, "subdir", "file.txt"),
			expected: filepath.Join("subdir", "file.txt"),
		},
		{
			name:     "absolute path outside cwd",
			path:     "/some/other/path/file.txt",
			expected: "/some/other/path/file.txt",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := relativePath(tt.path)
			// For paths outside cwd, relativePath returns absolute or relative depending on OS
			// Just check it doesn't panic and returns something reasonable
			if result == "" {
				t.Error("relativePath returned empty string")
			}
		})
	}
}

func TestProjectPaths(t *testing.T) {
	paths := config.NewProjectPaths("/my/project")

	if paths.Root != "/my/project" {
		t.Errorf("Root = %s, want /my/project", paths.Root)
	}

	if paths.StaghornDir != "/my/project/.staghorn" {
		t.Errorf("StaghornDir = %s, want /my/project/.staghorn", paths.StaghornDir)
	}

	if paths.SourceMD != "/my/project/.staghorn/project.md" {
		t.Errorf("SourceMD = %s, want /my/project/.staghorn/project.md", paths.SourceMD)
	}

	if paths.OutputMD != "/my/project/CLAUDE.md" {
		t.Errorf("OutputMD = %s, want /my/project/CLAUDE.md", paths.OutputMD)
	}

	if paths.CommandsDir != "/my/project/.staghorn/commands" {
		t.Errorf("CommandsDir = %s, want /my/project/.staghorn/commands", paths.CommandsDir)
	}
}

func TestTeamTemplatesDir(t *testing.T) {
	paths := config.NewPaths()
	result := paths.TeamTemplatesDir("myorg", "myrepo")

	if !strings.Contains(result, "myorg-myrepo-templates") {
		t.Errorf("TeamTemplatesDir should contain 'myorg-myrepo-templates', got %s", result)
	}
}
