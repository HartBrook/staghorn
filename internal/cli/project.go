package cli

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/HartBrook/staghorn/internal/config"
	"github.com/spf13/cobra"
)

// projectHeader is prepended to generated CLAUDE.md files.
const projectHeader = "<!-- Generated by staghorn from .staghorn/project.md - do not edit directly -->\n\n"

// defaultProjectTemplate is the initial content for .staghorn/project.md.
const defaultProjectTemplate = `# Project Guidelines

<!-- Add your project-specific Claude Code guidelines here -->

## Code Style

- Follow the existing code style in this repository

## Context

- This is a [describe your project type]

## Important Notes

- [Add any project-specific notes for Claude]
`

// NewProjectCmd creates the project parent command.
func NewProjectCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "project",
		Short: "Manage project-level CLAUDE.md config",
		Long: `Commands for managing project-level CLAUDE.md configuration.

Staghorn manages ./CLAUDE.md by generating it from .staghorn/project.md.
This provides a consistent experience across all three layers (team, personal, project).`,
	}

	cmd.AddCommand(NewProjectInitCmd())
	cmd.AddCommand(NewProjectEditCmd())
	cmd.AddCommand(NewProjectInfoCmd())
	cmd.AddCommand(NewProjectTemplatesCmd())

	return cmd
}

// NewProjectInitCmd creates the 'project init' command.
func NewProjectInitCmd() *cobra.Command {
	var templateName string

	cmd := &cobra.Command{
		Use:   "init",
		Short: "Initialize project-level config",
		Long: `Creates .staghorn/project.md and generates ./CLAUDE.md.

Use --template to start from a team-provided template instead of the default.`,
		Example: `  staghorn project init
  staghorn project init --template=backend-service`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runProjectInit(templateName)
		},
	}

	cmd.Flags().StringVarP(&templateName, "template", "t", "", "Use a team template (run 'staghorn project templates' to list)")

	return cmd
}

func runProjectInit(templateName string) error {
	projectRoot := findProjectRoot()
	projectPaths := config.NewProjectPaths(projectRoot)

	// Check if already initialized
	if _, err := os.Stat(projectPaths.SourceMD); err == nil {
		return fmt.Errorf("project already initialized: %s exists\nRun 'staghorn project edit' to modify it", projectPaths.SourceMD)
	}

	// Create .staghorn directory
	if err := os.MkdirAll(projectPaths.StaghornDir, 0755); err != nil {
		return fmt.Errorf("failed to create .staghorn directory: %w", err)
	}

	// Determine content: template or default
	var content string
	if templateName != "" {
		templateContent, err := loadTemplate(templateName)
		if err != nil {
			return err
		}
		content = templateContent
		printSuccess("Using template: %s", templateName)
	} else {
		content = defaultProjectTemplate
	}

	// Write project.md
	if err := os.WriteFile(projectPaths.SourceMD, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to create project.md: %w", err)
	}

	printSuccess("Created %s", relativePath(projectPaths.SourceMD))

	// Generate CLAUDE.md
	if err := generateProjectOutput(projectPaths); err != nil {
		return err
	}

	printSuccess("Generated %s", relativePath(projectPaths.OutputMD))
	fmt.Println()
	fmt.Printf("Edit your project config with: %s\n", info("staghorn project edit"))

	return nil
}

// loadTemplate loads a template from the team cache.
func loadTemplate(name string) (string, error) {
	paths := config.NewPaths()

	// Need to know which team repo to look in
	if !config.Exists() {
		return "", fmt.Errorf("staghorn not configured\nRun 'staghorn init' first to set up your team repo")
	}

	cfg, err := config.Load()
	if err != nil {
		return "", err
	}

	owner, repo, err := cfg.Team.ParseRepo()
	if err != nil {
		return "", err
	}

	// Look for template file
	templatesDir := paths.TeamTemplatesDir(owner, repo)
	templatePath := filepath.Join(templatesDir, name+".md")

	content, err := os.ReadFile(templatePath)
	if os.IsNotExist(err) {
		// List available templates for helpful error
		available := listAvailableTemplates(templatesDir)
		if len(available) == 0 {
			return "", fmt.Errorf("template '%s' not found\nNo templates available. Run 'staghorn sync' to fetch team templates.", name)
		}
		return "", fmt.Errorf("template '%s' not found\nAvailable templates: %s", name, strings.Join(available, ", "))
	}
	if err != nil {
		return "", fmt.Errorf("failed to read template: %w", err)
	}

	return string(content), nil
}

// listAvailableTemplates returns names of available templates.
func listAvailableTemplates(templatesDir string) []string {
	entries, err := os.ReadDir(templatesDir)
	if err != nil {
		return nil
	}

	var names []string
	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".md") {
			continue
		}
		name := strings.TrimSuffix(entry.Name(), ".md")
		names = append(names, name)
	}
	return names
}

// NewProjectEditCmd creates the 'project edit' command.
func NewProjectEditCmd() *cobra.Command {
	var noApply bool

	cmd := &cobra.Command{
		Use:   "edit",
		Short: "Edit project config (auto-applies on save)",
		Long: `Opens .staghorn/project.md in your editor and automatically applies changes.

Use --no-apply to edit without generating ./CLAUDE.md.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runProjectEditWithApply(noApply)
		},
	}

	cmd.Flags().BoolVar(&noApply, "no-apply", false, "Don't apply changes after editing")

	return cmd
}

func runProjectEditWithApply(noApply bool) error {
	projectRoot := findProjectRoot()
	paths := config.NewProjectPaths(projectRoot)

	// Check if initialized
	if _, err := os.Stat(paths.SourceMD); os.IsNotExist(err) {
		return fmt.Errorf("project not initialized\nRun 'staghorn project init' first")
	}

	// Open editor
	if err := openEditor(paths.SourceMD); err != nil {
		return err
	}

	fmt.Println()
	printSuccess("Project config saved")

	// Auto-apply unless --no-apply
	if noApply {
		fmt.Printf("  %s Run 'staghorn project info --content' to preview\n", dim("Tip:"))
		return nil
	}

	// Apply changes
	if err := generateProjectOutput(paths); err != nil {
		return err
	}

	printSuccess("Applied to %s", relativePath(paths.OutputMD))

	return nil
}

// NewProjectInfoCmd creates the 'project info' command.
func NewProjectInfoCmd() *cobra.Command {
	var content bool

	cmd := &cobra.Command{
		Use:   "info",
		Short: "Show project config status",
		Long: `Shows the current state of project-level config.

Use --content to preview the generated output.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runProjectInfo(content)
		},
	}

	cmd.Flags().BoolVar(&content, "content", false, "Show generated content instead of status")

	return cmd
}

func runProjectInfo(showContent bool) error {
	projectRoot := findProjectRoot()
	paths := config.NewProjectPaths(projectRoot)

	// Check if initialized
	if _, err := os.Stat(paths.SourceMD); os.IsNotExist(err) {
		fmt.Println(dim("Project config not initialized"))
		fmt.Println()
		fmt.Printf("Run %s to set up project config\n", info("staghorn project init"))
		return nil
	}

	// If --content, show generated output
	if showContent {
		content, err := os.ReadFile(paths.SourceMD)
		if err != nil {
			return fmt.Errorf("failed to read project.md: %w", err)
		}
		fmt.Print(projectHeader)
		fmt.Println(strings.TrimSpace(string(content)))
		return nil
	}

	// Show status
	sourceInfo, _ := os.Stat(paths.SourceMD)
	sourceContent, err := os.ReadFile(paths.SourceMD)
	if err != nil {
		return fmt.Errorf("failed to read project.md: %w", err)
	}
	sourceLines := bytes.Count(sourceContent, []byte("\n")) + 1

	fmt.Printf("  %s: %s (%d lines)\n", dim("Source"), relativePath(paths.SourceMD), sourceLines)
	fmt.Printf("  %s: %s\n", dim("Output"), relativePath(paths.OutputMD))

	// Check output status
	outputInfo, outputErr := os.Stat(paths.OutputMD)
	if os.IsNotExist(outputErr) {
		fmt.Printf("  %s: %s\n", dim("Status"), warning("not generated"))
		fmt.Println()
		fmt.Printf("Run %s to generate ./CLAUDE.md\n", info("staghorn project edit"))
		return nil
	}

	// Compare modification times
	if outputInfo.ModTime().Before(sourceInfo.ModTime()) {
		fmt.Printf("  %s: %s\n", dim("Status"), warning("out of date"))
		fmt.Println()
		fmt.Printf("Run %s to update ./CLAUDE.md\n", info("staghorn project edit"))
	} else {
		fmt.Printf("  %s: %s\n", dim("Status"), success("up to date"))
	}

	return nil
}

// generateProjectOutput writes the generated CLAUDE.md file.
func generateProjectOutput(paths *config.ProjectPaths) error {
	content, err := os.ReadFile(paths.SourceMD)
	if err != nil {
		return fmt.Errorf("failed to read project.md: %w", err)
	}

	output := projectHeader + strings.TrimSpace(string(content)) + "\n"

	if err := os.WriteFile(paths.OutputMD, []byte(output), 0644); err != nil {
		return fmt.Errorf("failed to write CLAUDE.md: %w", err)
	}

	// Set modification time to now to ensure it's newer than source
	now := time.Now()
	_ = os.Chtimes(paths.OutputMD, now, now) // Non-fatal if this fails

	return nil
}

// NewProjectTemplatesCmd creates the 'project templates' command.
func NewProjectTemplatesCmd() *cobra.Command {
	return &cobra.Command{
		Use:   "templates",
		Short: "List available project templates",
		Long: `Lists project templates from your team repository.

Templates provide starting points for project-level CLAUDE.md configs.
Use 'staghorn project init --template=<name>' to use one.`,
		RunE: func(cmd *cobra.Command, args []string) error {
			return runProjectTemplates()
		},
	}
}

func runProjectTemplates() error {
	paths := config.NewPaths()

	// Need to know which team repo to look in
	if !config.Exists() {
		return fmt.Errorf("staghorn not configured\nRun 'staghorn init' first to set up your team repo")
	}

	cfg, err := config.Load()
	if err != nil {
		return err
	}

	owner, repo, err := cfg.Team.ParseRepo()
	if err != nil {
		return err
	}

	templatesDir := paths.TeamTemplatesDir(owner, repo)
	templates := listAvailableTemplates(templatesDir)

	if len(templates) == 0 {
		fmt.Println("No templates available.")
		fmt.Println()
		fmt.Println("Templates come from your team repository's templates/ directory.")
		fmt.Printf("Run %s to fetch the latest.\n", info("staghorn sync"))
		return nil
	}

	fmt.Println(dim("AVAILABLE TEMPLATES"))
	fmt.Println()

	for _, name := range templates {
		// Try to read description from first line of template
		templatePath := filepath.Join(templatesDir, name+".md")
		desc := getTemplateDescription(templatePath)
		fmt.Printf("  %-20s %s\n", info(name), desc)
	}

	fmt.Println()
	fmt.Printf("Use: %s\n", info("staghorn project init --template=<name>"))

	return nil
}

// getTemplateDescription extracts a description from a template file.
func getTemplateDescription(path string) string {
	content, err := os.ReadFile(path)
	if err != nil {
		return "(no description)"
	}

	lines := strings.Split(string(content), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		// Skip empty lines, headings, and HTML comments
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "<!--") {
			continue
		}
		// Truncate if too long
		if len(line) > 50 {
			line = line[:47] + "..."
		}
		return line
	}

	return "(no description)"
}

// relativePath returns a path relative to cwd if possible.
func relativePath(path string) string {
	cwd, err := os.Getwd()
	if err != nil {
		return path
	}
	rel, err := filepath.Rel(cwd, path)
	if err != nil {
		return path
	}
	return rel
}
